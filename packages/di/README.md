# ProjectX.DI

_Библиотека для управления зависимостями_

[![ Версия npm ](https://badge.fury.io/js/projectx.di.svg)](https://badge.fury.io/js/projectx.di)

## Установка

```
npm i projectx.di
```

## Документация

Для чего нужен DI? Если вы разрабатываете приложение с использованием ООП то вы скорее всего столкнетесь с необходимостью подключения одного экземпляра класса к другому.

К примеру у нас есть состояние [projectx.state](https://github.com/VanyaKrotov/projectx/tree/main/packages/state) с набором необходимых экшенов для работы с данными, но нам также необходимо работать с сетью и каким-либо образом обрабытывать данные (реализовывать бизнесс логику) то наш класс состояния со временем разрастется до невиданных размеров, тут нам на помощь приходят сервисы, которые мы можем подключить и вынести часть функционала в них таким образом разгрузить состояние. Все супер, состояние небольшое все дублирование вынесено в сервис но что если функции этого сервиса необходимо в другом состоянии?! Создавать общий сервис и от него наследовать сервисы использующиеся в этих состояниях - вариант, но как по мне сложный, гораздо легче подключить сервис как зависимость к обоим состояниям и использовать ее.

### Описание функций и классов

- `Provider` - функция для создания провайдера для набора зависимостей.

  Возвращает методы для управления:

  - `register()` - метод регистрации зависимости;

  - `unregister()` - метод удаления зависимости;

  - `inject()` - метод захвата зависимости если она есть;

  - `injectAfterCreate()` - метод захвата зависимости если она есть, если нет ожидает регистрации;

  - `dispose()` - метод для сброса данных провайдера;

Пример:

```ts
class A {
  print() {
    return "A";
  }
}

class B {
  print() {
    return "B";
  }
}

const provider = new Provider("TestProvider");

provide.register(A);

const container = {
  a: provider.injectSync(A),
  b: null,
};

provider.injectAsync(B).then((b) => {
  container.b = b;
});

provide.register(B);

container.a.print();
// A

container.b.print();
// Error! Сannot get property `b` of null...

// Иммитация пользовательского события
setTimeout(() => {
  container.b.print();
  // B
});
```
